// generate:ignore-file
// generate:sort-first
export abstract class INexusNetworkObject {
    public _: boolean;
    public abstract toCleanObject(): any;
    public abstract toCacheObject(): any;
    public static toCleanObject(obj?: INexusNetworkObject): any {
        return obj ? obj.toCleanObject() : undefined;
    }
    public static toCleanObjects(objs: INexusNetworkObject[]): any[] {
        return objs.map(o => o.toCleanObject());
    }
    public toJSON(): any {
        try {
            return this.toCleanObject();
        } catch (err) {
            console.log("INetworkObject.toJSON()", err);
            return undefined;
        }
    }
}
// Automatically generated by Eta v2's /scripts/generate_indexes.py
export class Account {
    public constructor(init: Partial<Account>) {
        Object.assign(this, init);
    }
    public id: number;
    public person: Person;
    public password: string;
    public salt: string;
}
export class ExpressSession {
    public sid: string;
    public sess: object;
    public expire: Date;
}
/**
 * User-submitted feedback through various modals
 */
export class Feedback {
    public constructor(init: Partial<Feedback>) {
        Object.assign(this, init);
    }
    public id: number;
    public text: string;
    public created: Date;
    public author: Person;
}
// generate:ignore-file
export abstract class IPermissionEntity {
    public permissions?: Permission[];
    public abstract hasPermission(permission: Permission): boolean;
    public static hasPermission(entity: IPermissionEntity, permission: Permission): boolean {
        const permissionTokens: string[] = permission.split("/");
        if (!entity.permissions) {
            return false;
        }
        for (const testPermission of entity.permissions) {
            const testTokens: string[] = testPermission.split("/");
            const length: number = Math.max(permissionTokens.length, testTokens.length);
            for (let k = 0; k < length && testTokens.length > k && permissionTokens.length > k; k++) {
                if (testTokens[k] === "*") { // wildcard is a definite positive
                    return true;
                }
                if (testTokens[k] === permissionTokens[k]) { // possible match
                    if (k === length - 1) { // last element
                        return true;
                    }
                    // don't stop, could still match since it has till now
                } else { // definite mismatch
                    break;
                }
            }
        }
        return false;
    }
}
export class Person implements IPermissionEntity {
    public constructor(init: Partial<Person>) {
        Object.assign(this, init);
    }
    public id: number;
    public username: string;
    public email: string;
    public firstName: string;
    public lastName: string;
    public universityId?: string;
    public permissions?: Permission[];
    public created: Date;
    public feedbacks: Feedback[];
    public hasPermission(permission: Permission): boolean {
        return IPermissionEntity.hasPermission(this, permission);
    }
}
// generate:ignore-file
/**
 * Standard actions: create, view, update, delete, access
 * Operations on users should specify who the operation is performed on (self, other, all)
 */
export enum Permission {
    All = "*",
    AccessModuleAdmin = "access/module/admin",
    AccessModuleNexus = "access/module/nexus",
    AccessModuleCompass = "access/module/compass",
    AccessModuleLCManage = "access/module/lcmanage",
    // Admin
    AdminUpdateUsers = "admin/users/update/all",
    // Nexus
    /**
     * Whether a user can be a Nexus tutor or not
     */
    NexusUpdateView = "nexus/view/update/self",
    NexusCreateTable = "nexus/table/create",
    NexusUpdateUserType = "nexus/userType/update/all",
    NexusViewActiveTutors = "nexus/view/tutors/all",
    Test1 = "test1/test2",
    Test2 = "test1/test2/test3",
    Test3 = "test1/test2/test4/*",
    Test4 = "test2/test3",
    Test5 = "test1/test2/test4/test5",
    Test6 = "test1/test2/test5"
}
export class NexusAward {
    public constructor(init: Partial<NexusAward>) {
        Object.assign(this, init);
    }
    public id: number;
    public name: string;
    public commendations?: NexusCommendation[];
}
export class NexusCategory {
    public constructor(init: Partial<NexusCategory>) {
        Object.assign(this, init);
    }
    public id: number;
    public name: string;
    public rank: number;
    public isExclusive: boolean;
    public objectives?: NexusObjective[];
    public persons?: NexusPerson[];
    /**
     * Checks whether this category is valid within the given categories
     */
    public within(categories: NexusCategory[]): boolean {
        if (this.isExclusive) {
            return categories.find(c => c.id === this.id) !== undefined;
        }
        return categories.filter(c => {
            if (c.isExclusive) {
                return this.id === c.id;
            }
            return this.rank <= c.rank;
        }).length > 0;
    }
}
export class NexusChatMessage extends INexusNetworkObject {
    public constructor(init: Partial<NexusChatMessage>) {
        super();
        Object.assign(this, init);
    }
    public id: number;
    public text: string;
    public created: Date;
    public isGlobal: boolean;
    /**
     * A null value means the message was sent by the system.
     */
    public personTable: NexusPersonTable;
    public objective: NexusObjective;
    public toCleanObject(): any {
        return {
            id: this.id,
            text: this.text,
            created: this.created.getTime(),
            isGlobal: this.isGlobal,
            personTable: INexusNetworkObject.toCleanObject(this.personTable),
            objective: INexusNetworkObject.toCleanObject(this.objective)
        };
    }
    public toCacheObject(): any {
        return {
            text: this.text,
            created: this.created,
            is_global: this.isGlobal,
            personTableId: this.personTable ? this.personTable.id : undefined,
            objectiveId: this.objective.id
        };
    }
}
export class NexusCommendation extends INexusNetworkObject {
    public constructor(init: Partial<NexusCommendation>) {
        super();
        Object.assign(this, init);
    }
    public id: number;
    public created: Date;
    public award: NexusAward;
    public objective: NexusObjective;
    public from: NexusPersonTable;
    public to: NexusPersonTable;
    public toCleanObject(): any {
        return {
            id: this.id,
            award: this.award,
            objective: INexusNetworkObject.toCleanObject(this.objective),
            from: INexusNetworkObject.toCleanObject(this.from),
            to: INexusNetworkObject.toCleanObject(this.to)
        };
    }
    public toCacheObject(): any {
        return {
            awardId: this.award.id,
            objectiveId: this.objective.id,
            fromId: this.from.id,
            toId: this.to.id
        };
    }
}
export class NexusDrawObject extends INexusNetworkObject {
    public constructor(init: Partial<NexusDrawObject>) {
        super();
        Object.assign(this, init);
    }
    public id: number;
    public personTable: NexusPersonTable;
    public objective: NexusObjective;
    public text?: string;
    public created: Date;
    public startX: number;
    public startY: number;
    public endX: number;
    public endY: number;
    public tool: NexusDrawTool;
    public toCleanObject(): any {
        return {
            id: this.id,
            personTable: INexusNetworkObject.toCleanObject(this.personTable),
            objective: INexusNetworkObject.toCleanObject(this.objective),
            text: this.text,
            created: this.created.getTime(),
            startX: this.startX,
            startY: this.startY,
            endX: this.endX,
            endY: this.endY,
            tool: this.tool
        };
    }
    public toCacheObject(): any {
        return {
            text: this.text,
            created: this.created,
            "start_x": this.startX,
            "start_y": this.startY,
            "end_x": this.endX,
            "end_y": this.endY,
            tool: this.tool,
            personTableId: this.personTable.id,
            objectiveId: this.objective.id
        };
    }
}
export class NexusObjective extends INexusNetworkObject {
    public constructor(init: Partial<NexusObjective>) {
        super();
        Object.assign(this, init);
    }
    public id: number;
    public name: string;
    public status: NexusObjectiveStatus;
    public owner: NexusPersonTable;
    public solver?: NexusPersonTable;
    public category: NexusCategory;
    public commendation: NexusCommendation;
    public chatMessages: NexusChatMessage[] = [];
    public drawObjects: NexusDrawObject[] = [];
    public created: Date;
    public solvedAt?: Date;
    public table: NexusTable;
    public viewCount: number;
    public toCleanObject(all = false): any {
        const obj: any = {
            id: this.id,
            name: this.name,
            status: this.status,
            owner: INexusNetworkObject.toCleanObject(this.owner),
            solver: INexusNetworkObject.toCleanObject(this.solver),
            category: this.category,
            created: this.created,
            solvedAt: this.solvedAt,
            table: INexusNetworkObject.toCleanObject(this.table)
        };
        if (all) {
            obj.drawObjects = INexusNetworkObject.toCleanObjects(this.drawObjects);
            obj.chatMessages = INexusNetworkObject.toCleanObjects(this.chatMessages);
        }
        return obj;
    }
    public toCacheObject(): any {
        return {
            name: this.name,
            status: this.status,
            ownerId: this.owner.id,
            solverId: this.solver.id,
            categoryId: this.category.id,
            created: this.created,
            solvedAt: this.solvedAt,
            tableId: this.table.id
        };
    }
}
export class NexusPerson {
    public constructor(init: Partial<NexusPerson>) {
        Object.assign(this, init);
    }
    public personId: number;
    public person: Person;
    public categories?: NexusCategory[];
    public personTables?: NexusPersonTable[];
    public authoredComments?: NexusPersonComment[];
    public receivedComments?: NexusPersonComment[];
    public get firstName(): string { return this.person.firstName; }
    public get lastName(): string { return this.person.lastName; }
    public get username(): string { return this.person.username; }
    public get id(): number { return this.person.id; }
    public get email(): string { return this.person.email; }
    public get created(): Date { return this.person.created; }
}
export class NexusPersonComment {
    public constructor(init: Partial<NexusPersonComment>) {
        Object.assign(this, init);
    }
    public id: number;
    public text: string;
    public created: Date;
    public author: NexusPerson;
    public recipient: NexusPerson;
}
export class NexusPersonTable extends INexusNetworkObject {
    public constructor(init: Partial<NexusPersonTable>) {
        super();
        Object.assign(this, init);
    }
    public id: number;
    public type?: NexusTablePersonType;
    public color: string;
    public table: NexusTable;
    public person: NexusPerson;
    public chatMessages?: NexusChatMessage[];
    public givenCommendations?: NexusCommendation[];
    public receivedCommendations?: NexusCommendation[];
    public drawObjects?: NexusDrawObject[];
    public ownedObjectives?: NexusObjective[];
    public solvedObjectives?: NexusObjective[];
    public toCleanObject(): any {
        return {
            id: this.id,
            type: this.type,
            color: this.color,
            person: this.person
        };
    }
    public toCacheObject(): any {
        return {
            type: this.type,
            color: this.color,
            personId: this.person.id,
            tableId: this.table.id
        };
    }
}
export class NexusTable extends INexusNetworkObject {
    public constructor(init: Partial<NexusTable>) {
        super();
        Object.assign(this, init);
    }
    public id: number;
    public status: NexusTableStatus;
    public created: Date;
    public objectives: NexusObjective[] = [];
    public toCleanObject(): any {
        return {
            id: this.id,
            status: this.status,
            created: this.created
        };
    }
    public toCacheObject(): any {
        return {
            status: this.status,
            created: this.created
        };
    }
}
// generate:ignore-file
export enum NexusApiError {
    FileTypeNotSupported,
    InvalidLogin,
    PersonNotFound,
    RecordingNotFound,
    UploadTooLarge
}
// generate:ignore-file
export enum NexusApiResult {
    Redirected,
    GetSearchResults,
    Success,
    GetActiveTutors
}
// generate:ignore-file
export enum NexusDrawTool {
    Pencil = 0,
    Erase = 1,
    Line = 2,
    Text = 3,
    AreaErase = 4,
}
// generate:ignore-file
export enum NexusObjectiveStatus {
    Queued,
    InProgress,
    Aborted,
    Solved
}
// generate:ignore-file
export enum NexusTablePersonType {
    Owner = 0,
    Tutor = 1,
    Collaborator = 2
}
// generate:ignore-file
export enum NexusTableStatus {
    InProgress = 0,
    Aborted = 1,
    Solved = 2,
    /**
     * Used for tables that were in progress but were prevented from completion
     * because the server stopped.
     */
    Halted = 3
}
// generate:ignore-file
export enum NexusViewType {
    Student = 0,
    Tutor = 1
}
